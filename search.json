[{"title":"Neo4j_learn","url":"/2018/08/31/Neo4j-learn/","content":"# 查询语句\n没有标签的节点\n\n```\nMATCH (n) WHERE NOT labels(n) RETURN n\n```\n没有任何关系的节点\n\n```\nMATCH (s) WHERE NOT ()-[]-(s) RETURN s\n```\n\n长度为1-4的路径\n\n```\nMATCH (n)-[*1..4]-() RETURN ...\n```\na和b最短关系路径\n\n```\nMATCH p=shortestPath(\n(x:xxx{xxx:\"xxx\"})-[*]-(x:xxx{xxx:\"xxx\"})\n)\n```\n查找两个节点间有多个关系的节点对\n\n```\nmatch (a)-[r]->(b) with a,b,count(r) as cr where cr>1 return a,b,cr\n```\n---\n 和Tom Hanks共同出演不止电影的演员，有哪些？\n \n ```\nMATCH (tom { name: 'Tom Hanks' })--(r)--(otherPerson)\nWITH otherPerson, count(*) AS foaf\nWHERE foaf > 1\nRETURN otherPerson\n ```\n\ncount(*)计数的到底是什么呢？看来是r的数量，这似乎不是很符合直觉。\n\n---\ncollect简单例子\n\n```\nMATCH (n) where exists(n.name)\nWITH n\nORDER BY n.name desc limit 3\nRETURN collect(n.name)\n```\n\n---\n排除有环的路径\n\n1、\n\n```\nMATCH path = (x)-[:KNOWS*]-(y)\nUNWIND NODES(path) AS n  \nWITH path,   \nSIZE(COLLECT(DISTINCT n)) AS testLength   \nWHERE testLength = LENGTH(path) + 1\nRETURN path\n```\n\n2、\n\n  ```\nMATCH path = (x)-[:KNOWS*]-(y) \nWHERE SIZE(apoc.coll.toSet(NODES(path))) = LENGTH(path) + 1 \nRETURN path\n  ```\n\n3、\n\n```\nMATCH path = (x)-[:KNOWS*]-(y) \n      WHERE apoc.coll.duplicates(NODES(path)) = []\nRETURN path\n```\n\n\n---\n\nforeach用法\n\n ```\nMATCH p=(root{name:'root'})-[r]-(A) \nFOREACH (n IN nodes(p) | SET n.marked=TRUE )\n ```\n```\nMATCH (a {name: 'root' })\nFOREACH (name IN [\"Mike\", \"Carl\", \"Bruce\"] | \nCREATE (a)-[:FRIEND]->(:Person {name: name}))\n```\n\n---\nUNWIND，把列表解开成行\n\n```\nWITH [1, 1, 2, 2] AS coll\nUNWIND coll AS x\nWITH DISTINCT x\nRETURN collect(x)\n```\n这是先解开后去重，再collect恢复成列表\n\n---\n\n找出所有属性，并统计在节点中出现的数量\n\n```\nCALL db.propertyKeys() YIELD propertyKey AS prop\nMATCH (n)\nWHERE n[prop] IS NOT NULL \nRETURN prop, count(n) AS numNodes\n```\n\n用db.propertyKeys()列出所有属性名，在所有节点中筛选包含属性prop的进行计数\n\n---\n\nall()\n\n```\nMATCH p =(a)-[*1..3]->(b)\nWHERE ALL (x IN nodes(p) WHERE x.age > 30)\nRETURN p\n```\n\n断言函数all，用法 fun(v IN list WHERE predicate)\n\n还有any, none, single, exists\n\n```\nMATCH p =(n)-->(b)\nWHERE SINGLE (var IN nodes(p) WHERE var.eyes = 'blue')\nRETURN p\n```\n整条路径只有一个节点eyes属性为blue\n\n```\nMATCH (n)\nWHERE exists(n.name)\nRETURN n.name AS name, exists((n)-[:MARRIED]->()) AS is_married\n```\n查找所有人，并显示是否已婚\n\n---\nsize()\n\n```\nMATCH (a)\nWHERE a.name = 'Alice'\nRETURN size((a)-->()-->()) AS fof\n```\n\nAlice->()->()这样的路径有多少个？用size((a)-->()-->())返回得到。\n\n---\n\nextract()\n\n可以使用extract()从节点或关系列表中返回单个属性或者某个函数的值。它将遍历整个列表，针对列表中的每个元素运行一个表达式，然后以列表的形式返回这些结果。\n\n```\nMATCH p =(a)-->(b)-->(c)\nWHERE a.name = 'Alice' AND b.name = 'Bob' AND c.name = 'Daniel'\nRETURN extract(n IN nodes(p)| n.age) AS extracted\n```\n\n通过extract(n IN nodes(p) | n.age)获得路径p中所有节点的年龄，组成列表\n\n---\n\nreduce()\n\n类似python里的reduce\n\n```\nMATCH p =(a)-->(b)-->(c)\nWHERE a.name = 'Alice' AND b.name = 'Bob' AND c.name = 'Daniel'\nRETURN reduce(totalAge = 0, n IN nodes(p)| totalAge + n.age) AS reduction\n```\n\n只要其中年龄大于30的加起来，可以用case when\n\n```\nMATCH p =(a)-->(b)-->(c)\nWHERE a.name = 'Alice' AND b.name = 'Bob' AND c.name = 'Daniel'\nRETURN reduce(totalAge = 0, n IN nodes(p)| totalAge + (case when n.age>30 then n.age else 0 end) ) AS reduction\n```\n\n\n将路径p里所有节点的年龄加起来\n\n---\n同名的节点合并为一个\n\n```\nMATCH (n:Tag)\nWITH n.name AS name, COLLECT(n) AS nodelist, COUNT(*) AS count\nWHERE count > 1\nCALL apoc.refactor.mergeNodes(nodelist) YIELD node\nRETURN node\n```\n\n关系的合并\n\n```\nMATCH (a:X)-[r]->(b:Y)\nWITH a, b, collect(r) as rels\nCALL apoc.refactor.mergeRelationships(rels,{properties:\"combine\"})\nYIELD rel RETURN rel\n```\n\n---\n# 索引、约束、统计\n\n索引\n\n```\nCREATE INDEX ON :Person(name)\n```\n\n约束，有节点属性的唯一性约束；节点和关系的属性存在性约束。但存在性约束仅限于企业版提供这个功能。\n\n```\nCREATE CONSTRAINT ON (book:Book) ASSERT book.isbn IS UNIQUE\nCREATE CONSTRAINT ON (book:Book) ASSERT exists(book.isbn) \nCREATE CONSTRAINT ON ()-[like:LIKED]-() ASSERT exists(like.day)\n```\n---\n# 执行与调优\n\nEXPLAIN、PROFILE，前者不真正执行。\n\n使用USING语句：\n1、索引提示\n2、扫描提示\n3、连接提示\n\n索引提示\n\n```\nPROFILE\nMATCH (p:Person { name: 'Tom Hanks' })\nUSING INDEX p: Person (name)\nRETURN p.born AS column\n```\n\n扫描提示\n\n```\nPROFILE\nMATCH (s: Person)\nUSING SCAN s: Person\nWHERE s.born < 1939\nRETURN s.born AS column\n```\n\n连接提示\n\n```\nMATCH (n1: Person { name:'Keanu Reeves' })-[: ACTED_IN]->(m1: Movie)<-[: DIRECTED]-(n2: Person {name:'Lilly Wachowski' })-[: DIRECTED]->(m2: Movie { title:'The Matrix Reloaded' })\nUSING INDEX n1: Person (name)\nUSING JOIN ON m1,n2\nRETURN m1.title AS column\n```\n\n---\n\n# 嵌入式java开发模式\nmaven\n\n```\n<dependencies>\n\t<dependency>\n\t\t<groupId>org.neo4j</groupId>\n\t\t<artifactId>neo4j</artifactId>\n\t\t<version>3.4.0</version>\n\t</dependency>\n</dependencies>\n        \n```\n\n创建一个新db（数据库文件在当前目录的target目录下）；\n或者选择已有的graph.db\n\n```\nprivate static final File databaseDirectory = new File(\"target/neo4j-hello-db\");\nvoid createDb() throws IOException {\n        FileUtils.deleteRecursively(databaseDirectory);\n        //要创建一个新的数据库或者打开一个已经存在的数据库，\n        //首先，需要创建一个GraphDatabaseService实例。\n        //GraphDatabaseService实例可以在多个线程之间共享。 \n        //但不能创建指向同一数据库的多个实例。\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase(databaseDirectory);\n        \n        //如果是根据配置文件启动\n        //GraphDatabaseService graphDb = new GraphDatabaseFactory()\n        //.newEmbeddedDatabaseBuilder( testDirectory.graphDbDir() )\n    \t //.loadPropertiesFromFile( pathToConfig + \"neo4j.conf\" )\n    \t //.newGraphDatabase();\n    \t \n    \t //如果直接再Java代码里设置\n    \t //GraphDatabaseService graphDb = new GraphDatabaseFactory()\n        //.newEmbeddedDatabaseBuilder( testDirectory.graphDbDir() )\n        //.setConfig( GraphDatabaseSettings.pagecache_memory, \"512M\" )\n        //.setConfig( GraphDatabaseSettings.string_block_size, \"60\" )\n        //.setConfig( GraphDatabaseSettings.array_block_size, \"300\" )\n        //.newGraphDatabase();\n        \n\t\t //如果只启动只读实例，这个应该很有用\n\t\t //graphDb = new GraphDatabaseFactory().newEmbeddedDatabaseBuilder( dir )\n        //.setConfig( GraphDatabaseSettings.read_only, \"true\" )\n        //.newGraphDatabase();\n\n\n        registerShutdownHook(graphDb);\n        try (Transaction tx = graphDb.beginTx()) {\n            ...\n            tx.success();\n        }catch(Exception e){\n    \t\t\ttx.failure();\n\t\t\t}finally{\n    \t\t\ttx.finish();\n          }\n\n}\n\nprivate static void registerShutdownHook( final GraphDatabaseService graphDb ){\n        // Registers a shutdown hook for the Neo4j instance so that it\n        // shuts down nicely when the VM exits (even if you \"Ctrl-C\" the running application).\n        Runtime.getRuntime().addShutdownHook( new Thread()\n        {\n            @Override\n            public void run()\n            {\n                graphDb.shutdown();\n            }\n        } );\n}\n```\n\n建标签、节点、属性、关系，删除关系\n\n```\npublic enum MyLabels implements Label{Person}\n\nfirstNode = graphDb.createNode();\n\nfirstNode.setProperty(\"message\", \"Hello, \");\n\n//用cypher语句创建\nString query=\"Create ...\";//返回了一个节点joe\nResult res=db.execute(query); \nObject joe=res.columnAs(\"joe\").next();\nif(joe instanceof Node){ return (Node) joe;}\nelse{throw new RuntimeException(\"joe isn't a node\");\n\nfirstNode.addLabel(MyLabels.Person);\n\nprivate enum RelTypes implements RelationshipType { KNOWS }\n\nrelationship = firstNode.createRelationshipTo(secondNode, RelTypes.KNOWS);\n\nfirstNode.getSingleRelationship( RelTypes.KNOWS, Direction.OUTGOING ).delete();\n```\n\n遍历\n\n\n```\nprivate GraphDatabaseService db;\nprivate TraversalDescription friendsTraversal;\npublic static void main( String[] args ) throws IOException\n{\n    FileUtils.deleteRecursively( databaseDirectory );\n    TraversalExample example = new TraversalExample(  );\n    Node joe = example.createData();\n    example.run(joe);\n}\n\npublic TraversalExample( )\n{\n    this.db =  new GraphDatabaseFactory().newEmbeddedDatabase( databaseDirectory );\n    friendsTraversal = db.traversalDescription()\n            .depthFirst()\n            .relationships( Rels.KNOWS )\n            .uniqueness( Uniqueness.RELATIONSHIP_GLOBAL );\n}\n\nprivate void run( Node joe )\n{\n    try (Transaction tx = db.beginTx())\n    {\n        //out.println( relationships( joe ) );\n        //out.println( nodes( joe ) );\n        out.println( knowsLikesTraverser( joe ));\n    }\n }\n \npublic String nodes( Node node )\n{\n    String output = \"\";\n    // START SNIPPET: nodes\n    for ( Node currentNode : friendsTraversal\n            .traverse( node )\n            .nodes() )\n    {\n        output += currentNode.getProperty( \"name\" ) + \"\\n\";\n    }\n    // END SNIPPET: nodes\n    return output;\n}\n\npublic String relationships( Node node )\n{\n    String output = \"\";\n    for ( Relationship relationship : friendsTraversal\n            .traverse( node )\n            .relationships() )\n    {\n        output += relationship.getType().name() + \"\\n\";\n    }\n    return output;\n}\n\npublic String knowsLikesTraverser( Node node )\n{\n\tString output = \"\";\n\tfor ( Path position : db.traversalDescription()\n                .depthFirst() // 指定深度优先\n                //.breadthFirst() //指定广度优先\n                .relationships( Rels.KNOWS ) //指定遍历KNOWS关系，没有指定关系指向\n                .relationships( Rels.LIKES, Direction.INCOMING )//指定遍历LIKES关系，指定关系指向为 INCOMING\n                .evaluator( Evaluators.fromDepth( 2 ) )\n                .evaluator( Evaluators.toDepth( 5 ) ) //指定最深的遍历深度为5，即遍历后的结果路径长度都为 5或更短\n                .traverse( node ) ) //指定遍历开始的节点\n    {\n        output += position + \"\\n\";\n    }\n        // END SNIPPET: knowslikestraverser\n        return output;\n}\n\n```\n\n根据标签、属性查找节点\n\n```\n// ResourceIterator<Node> findNodes(Label label) \nResourceIterator<Node> persons=graphDb.findNodes(MyLabels.Person);\npersons.forEachRemaining((entityTypeGraphNode) -> {\n    System.out.print( entityTypeGraphNode.getProperties(\"message\"));\n    Iterable<Relationship> typeObjectsRelationships = entityTypeGraphNode.getRelationships();\n    typeObjectsRelationships.forEach(\n        (relationship) -> {\n            Node entityGraphNode = relationship.getEndNode();\n            System.out.print( entityGraphNode.getProperty(\"message\"));                        \n        }\n    );\n});\n```\n---\n\n对于遍历，需要了解一些概念：\n\n1、路径扩展（PathExpander）：一般是指关系的指向、关系的类型。\n\n2、顺序（Order）：如深度优先或广度优先。\n\n3、唯一性（Uniqueness）：确保每个节点（或关系、路径）指遍历一次。\n\n4、开始节点\n\n---\n索引\n\n创建索引\n\n```\nIndexManager index = graphDb.index();\nIndex<Node> actors = index.forNodes( \"actors\" );\nIndex<Node> movies = index.forNodes( \"movies\" );\nRelationshipIndex roles = index.forRelationships( \"roles\" );\n//删除actors索引\nactors.delete()\n```\n\n确认索引是否已存在\n\n```\nIndexManager index = graphDb.index();\nboolean indexExists = index.existsForNodes( \"actors\" );\n```\n\n将索引添加到节点（的属性上）\n\n```\nNode reeves = graphDb.createNode();\nreeves.setProperty( \"name\", \"Keanu Reeves\" ); \n//不是很理解为什么会需要第三个参数\nactors.add( reeves, \"name\", reeves.getProperty( \"name\" ) ); \n```\n\n将索引添加到关系（的属性上）\n\n```\nRelationshipIndex roles = index.forRelationships( \"roles\" );\nRelationshipType ACTS_IN = RelationshipType.withName( \"ACTS_IN\" );\nRelationship role1 = reeves.createRelationshipTo( theMatrix, ACTS_IN );\nrole1.setProperty( \"name\", \"Neo\" );\nroles.add( role1, \"name\", role1.getProperty( \"name\" ) );\n```\n\n节点索引下的查询\n\n1、get方法\n\n```\nIndexHits<Node> hits = actors.get( \"name\", \"Keanu Reeves\" )\n//getSingle只返回第一个也是唯一的项不存在则返回null，多个则抛出oSuchElementException \nNode reeves = hits.getSingle();\n```\n\n```\nRelationship persephone = roles.get( \"name\", \"Persephone\" ).getSingle();\nNode actor = persephone.getStartNode();\nNode movie = persephone.getEndNode();\n\nfor ( Relationship role : roles.get( \"name\", \"Neo\" ) )\n{\n    Node reeves = role.getStartNode();\n}\n```\n\n2、query方法\n\n```\nfor ( Node movie : movies.query( \"title:*Matrix* AND year:1999\" ) )\n{\n    // 返回结果为 1999年的 \"The Matrix\".\n}\n```\n\n```\n// 查询一个以reeves作为开始节点的关系\n// 使用单一键值对的匹配方法\nIndexHits<Relationship> reevesAsNeoHits;\nreevesAsNeoHits = roles.get( \"name\", \"Neo\", reeves, null );\nRelationship reevesAsNeo = reevesAsNeoHits.iterator().next();\nreevesAsNeoHits.close();\n//查询一个以theMatrix作为结束节点的关系\n// 使用query方法\nIndexHits<Relationship> matrixNeoHits;\nmatrixNeoHits = roles.query( \"name\", \"*eo\", null, theMatrix );\nRelationship matrixNeo = matrixNeoHits.iterator().next();\nmatrixNeoHits.close();\n```\n\n结果相似度评分\n\n```\nIndexHits<Node> hits = movies.query( \"title\", \"The*\" );\nfor ( Node movie : hits )\n{\n    System.out.println( movie.getProperty( \"title\" ) + \" \" + hits.currentScore() );\n}\n```\n\n全文索引（略）\n\n---\n\n过程（Procedure）是以Java编写然后部署到数据库中的扩展插件，过程可以在Cypher中调用。\n\n过程是扩展Neo4j的首选手段。过程能够提供的功能如下：\n\n（1）提供对Cypher中不可用的功能的访问，例如手动索引；\n\n（2）提供对第三方系统的访问；\n\n（3）执行全局操作，例如对连接的组件计数或查找密集节点；\n\n（4）实现难以用Cypher明确表达的操作。\n\n---\n\n自定义过程\n\npom文件\n\n```\n<!-- 指明打包为jar文件 -->\n  <packaging>jar</packaging>\n  <name>Neo4j Procedure Template</name>\n  <description>xxx</description>\n  \n  \n   <dependencies>\n <!-- neo4j的依赖包-->\n  <dependency>\n   <groupId>org.neo4j</groupId>\n   <artifactId>neo4j</artifactId>\n   <version>3.4.0</version>\n   <scope>provided</scope> <!-- 注意：必须 指明不需要把此依赖中的jar打包进去 -->\n  </dependency>  \n </dependencies>\n  \n <!--  指明将本项目打包，并配置打包 -->\n    <build>\n    <plugins>\n      <plugin>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.1</version>\n        <configuration>\n          <!-- Neo4j 过程需要  Java 8 -->\n          <source>1.8</source>\n          <target>1.8</target>\n        </configuration>\n      </plugin>\n      <plugin>\n        <!-- 生成jar文件-->\n        <artifactId>maven-shade-plugin</artifactId>\n        <version>2.4.3</version>\n        <executions>\n          <execution>\n            <phase>package</phase>\n            <goals>\n              <goal>shade</goal>\n            </goals>\n          </execution>\n        </executions>\n      </plugin>\n    </plugins>\n  </build>\n```\n\n\n ```\n\n//创建一个过程，实现对节点 创建 全文索引功能, 使用mvn clean package 命令 对本项目打包，生成 jar 文件\n/* 调用com.xxx.neo4j.index 将节点添加到我们创建的索引里\n * MATCH (n:Person)\nCALL com.xxx.neo4j.index(id(n), ['name'])\nRETURN n;\n\n调用com.xxx.neo4j.search 去从索引里查询节点并返回 nodeId\nCALL com.xxx.neo4j.search('Person','name:Jo*')\n\n*/\npublic class FullTextIndex {\n\n\t@Context // 使用注解方式，实例化GraphDatabaseService\n\tpublic GraphDatabaseService db;\n\n\t// 声明一个全文索引的配置\n\tprivate static final Map<String, String> FULL_TEXT = stringMap(IndexManager.PROVIDER, \"lucene\", \"type\", \"fulltext\");\n\n\t@Context\n\tpublic Log log;\n\t\n\t\n\t/*\n\t * 创建一个名为 com.xxx.neo4j.index的过程， 将指定id的节点 添加到新创建的索引里面\n\t */\n\t@Procedure(value = \"com.xxx.neo4j.index\", mode=Mode.WRITE)\n    @Description(\"用户自定义过程实例index，将指定id的节点 添加到新创建的索引里面\")\n    public void index( @Name(\"nodeId\") long nodeId,\n                       @Name(\"properties\") List<String> propKeys )\n    {\n\t\t//所有neo4j嵌入式开发中的所有操作，都可以写入到我们这个过程内部\n\t\t\n        Node node = db.getNodeById( nodeId );\n\n        // 将nodes节点里面的所有属性拿出来拼装到一个 set里.\n        Set<Map.Entry<String,Object>> properties =\n                node.getProperties( propKeys.toArray( new String[0] ) ).entrySet();\n\n        // Index every label (this is just as an example, we could filter which labels to index)\n        for ( Label label : node.getLabels() )\n        {\n            Index<Node> index = db.index().forNodes( indexName( label.name() ), FULL_TEXT );\n\n            // 先确保 此节点不在 我们创建的index索引里\n            index.remove( node );\n\n            // 将node节点 按照它带有的全部属性，去将node节点添加到index索引里面\n            for ( Map.Entry<String,Object> property : properties )\n            {\n                index.add( node, property.getKey(), property.getValue() );\n            }\n        }\n    }\n\t\n\t/* \n\t * 通过我们创建的索引，按条件查询出节点\n\t */\n\t @Procedure(value = \"com.xxx.neo4j.search\")\n\t    @Description(\"通过我们创建的索引，按条件查询出节点\")\n\t    public Stream<SearchHit> search( @Name(\"label\") String label,\n\t                                     @Name(\"query\") String query )\n\t    {\n\t        String index = indexName( label );\n\n\t        // 检查此索引是否已经在数据库里存在\n\t        if( !db.index().existsForNodes( index ))\n\t        {\n\t            // Just to show how you'd do logging\n\t            log.debug( \"索引不存在: `%s`\", index );\n\t            return Stream.empty();\n\t        }\n\n\t        // 如果索引存在，就返回通过索引查询的结果\n\t        return db.index()\n\t                .forNodes( index )\n\t                .query( query ) //可以用通配符 *user?\n\t                .stream()\n\t                .map( SearchHit::new );\n\t    }\n\t \n\t    public static class SearchHit\n\t    {\n\t        // This records contain a single field named 'nodeId'\n\t        public long nodeId;\n\n\t        public SearchHit( Node node )\n\t        {\n\t            this.nodeId = node.getId();\n\t        }\n\t    }\n\t    \n\t\n\tprivate String indexName( String label )\n    {\n        return \"label-\" + label;\n    }\n\n}\n ```\n\n\n\n自定义聚合函数\n\n用户定义的聚合函数使用@UserAggregationFunction进行注释。 带注释的函数必须返回聚合器类的实例。聚合器类包含一个用@UserAggregationUpdate注解的方法和@UserAggregationResult注解的方法。使用@UserAggregationUpdate注解的方法将被多次调用 对数据进行聚合操作。聚合完成后将使用@UserAggregationResult注释的方法并返回聚合结果。","tags":["Neo4j ; data"]},{"title":"biu","url":"/2018/08/26/biu/","content":"开始分省库汇聚后的数据处理工作，估计还会有不少问题，做好心理准备，嗯。\n\n待填的坑大概有：\n\n### 数据质量分析\n肯定有些是没法解决的，只能投放后留给后人了，但所有质量问题都要留下处理方案。\n\n### 各省验证\n唯一的作用就是让各省签字吧……指望不上他们能主动处理什么问题，做的越多，风险越大。\n\n### 投放\n这是深坑，估计会有不少问题。\n\n### 反省\n文档、附件、脚本和组织等等问题太多了，都需要重新调整，我们4个90后祭天兄弟团，必定是要踩不少雷，但如果这次吃够了教训，也许能确保9月安全着陆。\n\n### 总结\n嗯，主要是给老板们看的。","tags":["数据 ITS"]}]